<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-spinner/paper-spinner.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-backend/tf-backend.html">
<link rel="import" href="../tf-color-scale/tf-color-scale.html">
<link rel="import" href="../tf-dashboard-common/scrollbar-style.html">
<link rel="import" href="../tf-dashboard-common/tf-multi-checkbox.html">
<link rel="import" href="../tf-tensorboard/registry.html">
<link rel="import" href="../tf-dashboard-common/run-color-style.html">
<dom-module id="runsenabler-dashboard">
    <style include="scrollbar-style"></style>
    <style include="run-color-style"></style>
    <template class="main-content">
      <template class="runenabler-spinner" is="dom-if" if="[[_isReloading]]">
        <paper-spinner active alt="Now loading runs..."></paper-spinner>
      </template>
      <template class="runsenabler-content" is="dom-if" if="[[!_isReloading]]">
        <div>
          <div>
            <paper-input
              id="runs-regex"
              no-label-float
              label="Write a regex to filter all runs into groups"
              value="[[regex]]"
              on-bind-value-changed="_debouncedRegexChange">
            </paper-input>
          </div>
          <div>
            <paper-input
              id="displayed-runs-regex"
              no-label-float
              label="Write a regex to filter runs which are displayed"
              value="[[regex]]"
              on-bind-value-changed="_debouncedGroupRunsRegexChange">
            </paper-input>
          </div>
          <div>
            <div class="checkbox-container vertical-align-container">
              <paper-checkbox class="checkbox vertical-align-center enable-new-runs-container" name="enable-new-runs-checkbox" checked="{{_enableNewRuns}}"></paper-checkbox>
              <div class="item-label-container">
                  <span>Enable newly discovered runs</span>
              </div>
            </div>
            <div class="reload-help">Reload the dashboard to update the loaded runs</div>
          </div>
        </div>
        <div id="outer-container" class="scrollbar horizontal">
          <div class="column">
            <paper-button on-tap="enableAll" raised>Enable all groups</paper-button>
            <paper-button on-tap="disableAll" raised>Disable all groups</paper-button>
            <template is="dom-repeat" items="[[_runGroupKeys]]" as="groupKey">
                <div class="checkbox-container vertical-align-container group-heading">
                  <paper-checkbox
                    class="checkbox vertical-align-center"
                    name="[[groupKey.runKey]]"
                    checked="{{groupKey.checked}}"
                    on-change="toggleRunsInGroup"
                  >
                  </paper-checkbox>
                  <div class="item-label-container">
                      <span>run group: " [[groupKey.runKey]] "</span>
                  </div>
                </div>
            </template>
          </div>
          <div class="column">
            <paper-button on-tap="enableAllDisplayedRuns" raised>Enable all displayed runs</paper-button>
            <paper-button on-tap="disableAllDisplayedRuns" raised>Disable all displayed runs</paper-button>
            <template is="dom-repeat" items="[[_runGroups]]" as="runGroup">
              <div class="group-heading">
                  <span>runs matching " [[runGroup.groupKey]] "</span>
              </div>
              <template is="dom-repeat" items="[[runGroup.runs]]" as="run" id$="[[runGroup.groupKey]]-group">
                <div class="checkbox-container vertical-align-container run-group">
                  <paper-checkbox
                    class="checkbox vertical-align-center"
                    name="[[run.run]]"
                    checked="{{run.checked}}"
                    on-change="_checkboxChange"
                    >
                  </paper-checkbox>
                  <div class="item-label-container">
                      <span>[[run.run]]</span>
                  </div>
                </div>
              </template>
            </template>
          </div>
        </div>  

      </template>
    <style>
      paper-input {
        --paper-input-container-focus-color: var(--tb-orange-strong);
        --paper-input-container-input: {
          font-size: 14px;
        };
        --paper-input-container-label: {
          font-size: 14px;
        };
      }

      .group-heading {
        padding: 10px;
      }

      .run-group {
        margin-left: 50px;
        padding: 5px;
      }

      .reload-help {
        padding: 5px;
      }

      .runenabler-spinner{
        width: 100%;
        height: 100%;
        background: rgba(255,255,255,1.0);
      }

      paper-spinner {
        display: block;
        margin: auto auto auto auto; 
        width: 100px;
        top: 50%;
        height: 100px;
        margin-top: -50px;  
      }

      :host {
        display: flex;
        flex-direction: column;
        height: 100%;
      }
      #outer-container {
        overflow-y: auto;
        overflow-x: hidden;
        width: 100%;
        flex-grow: 1;
        flex-shrink: 1;
        word-wrap: break-word;
      }
      .run-row {
        padding-top: 5px;
        padding-bottom: 5px;
        display: flex;
        flex-direction: row;
        font-size: 13px;
        word-break: break-all; /* makes wrapping of hyperparam strings better */
      }
      .icon-container {
        flex-grow: 0;
        flex-shrink: 0;
        padding-left: 2px;
      }
      .checkbox {
        padding-left: 2px;
        width: 18px;
        height: 18px;
      }
      .isolator {
        width: 18px;
        height: 18px;
        padding: 0px;
      }
      .isolator-container {
        padding-left: 6px;
        padding-right: 3px;
      }
      .checkbox-container {
        padding-left: 2px;
      }
      .item-label-container {
        padding-left: 5px;
        flex-grow: 1;
        flex-shrink: 1;
        width: 0px; /* hack to get the flex-grow to work properly */
      }
      .tooltip-value-container {
        display: flex;
        justify-content: center;
        flex-grow: 0;
        flex-shrink: 0;
        text-align:right;
        padding-left: 2px;
      }
      .vertical-align-container {
        display: flex;
        justify-content: center;
      }
      .vertical-align-container .vertical-align-center {
        align-self: center;
      }
      .vertical-align-container .vertical-align-top {
        align-self: start;
      }
      .column {
        display: inline-block;
        width: 45%;
        vertical-align: top;
      }

      .enable-new-runs-container {
        padding: 5px;
      }

    </style>
    </template>
    <script>
        Polymer({
          is: 'runsenabler-dashboard',
          properties: {
              runs: Array,
              _isReloading: Boolean,
              _requestManager: {
                  type: Object,
                  value: () => new tf_backend.RequestManager(50),
              }, 
              coloring: {
                  type: Object,
                  value: {
                      getColor: () => '',
                  },
              },
              displayedRuns: {
                type: Array,
                computed: 'computeDisplayedRuns(_runGroups)'
              },
              displayedRunsRegex: {
                type: String, 
                notify: true,
                value: '',
              },
              _displayedRunsRegex: {
                type: Object, 
                computed: '_makeRegex(displayedRunsRegex)'
              },
              regex: {
                  type: String,
                  notify: true,
                  value: '',
              },  // Regex for filtering the names
              _regex: {type: Object, computed: '_makeRegex(regex)'},
              runsMatchingRegex: {
                  type: Array,
                  computed: 'computeNamesMatchingRegex(runs, _regex)'
              },  // Runs that match the regex
              runsNotMatchingRegex: {
                type: Array,
                computed: 'computeNamesNotMatchingRegex(runs, _regex)'
              },
              _runGroupObject: {
                type: Object,
                computed: 'computeRunGroupObject(_regex, runSelectionState)',
              },
              _runGroups: {
                type: Array,
                value: () => [],
              },
              _runGroupKeys: {
                type: Array,
                computed: 'computeRunGroupKeys(_runGroupObject)',
              },
              runSelectionState: {
                  // if a name is explicitly enabled, True, if explicitly disabled, False.
                  // if undefined, default value (enable for first k names, disable after).
                  type: Object,
                  notify: true,
                  value: () => ({}),
              },
              isChecked: {
                  type: Function,
                  value: function() {
                      return (run) => this.runSelectionState[run]
                  },
              },
              _enableNewRuns: {
                type: Boolean,
                value: false
              },
              _debouncedRegexChange: {
                  type: Object,
                  // Updating the regex can be slow, because it involves updating styles
                  // on a large number of Polymer paper-checkboxes. We don't want to do
                  // this while the user is typing, as it may make a bad, laggy UI.
                  // So we debounce the updates that come from user typing.
                  value: function() {
                      var debounced = _.debounce(r => {
                          this.regex = r;
                          this.disableRunsNotMatchingRegex();
                      }, 150, {leading: false});
                      return function() {
                          var r = this.$$('#runs-regex').value;
                          if (r == '') {
                              // If the user cleared the field, they may be done typing, so
                              // update more quickly.
                              this.async(() => {
                                  this.regex = r;
                              }, 30);
                          } else {
                              debounced(r);
                          };
                      };
                  },
              },
              _debouncedGroupRunsRegexChange: {
                type: Object,
                // Updating the regex can be slow, because it involves updating styles
                // on a large number of Polymer paper-checkboxes. We don't want to do
                // this while the user is typing, as it may make a bad, laggy UI.
                // So we debounce the updates that come from user typing.
                value: function() {
                  var debounced = _.debounce(r => {
                      this.displayedRunsRegex = r;
                  }, 150, {leading: false});
                  return function() {
                      var r = this.$$('#displayed-runs-regex').value;
                      if (r == '') {
                          // If the user cleared the field, they may be done typing, so
                          // update more quickly.
                          this.async(() => {
                              this.displayedRunsRegex = r;
                          }, 30);
                      } else {
                          debounced(r);
                      };
                  };
                },
              },
              maxNamesToEnableByDefault: {
                  // When TB first loads, if it has k or fewer names, they are all enabled
                  // by default. If there are more, then they are all disabled.
                  type: Number,
                  value: 40,
              },
          },
          listeners: {
              'dom-change': 'synchronizeColors',
          },
          observers:[
            'updateRunGroups(_runGroupKeys, _displayedRunsRegex)'
          ],
          computeDisplayedRuns(runGroups){
            return [].concat.apply(runGroups.map(runGroup => runGroup.runs)).map(run => run.run);
          },
          enableAllDisplayedRuns(){
            const keys = this._runGroups.map(runGroup => runGroup.groupKey);
            for(let key in keys){
              this._updateRunCheckboxesByGroup(key, true);
              this._enableAllRunsMatchingRegexSubstring(key);
            }
          }, 
          disableAllDisplayedRuns(){
            const keys = this._runGroups.map(runGroup => runGroup.groupKey);
            for(let key in keys){
              this._updateRunCheckboxesByGroup(key, false);
              this._disableAllRunsMatchingRegexSubstring(key);
            }
          }, 
          toggleRunsInGroup(event){
            // Compute the set of groups which will be displayed in the dashboard 
            this.updateRunGroups();
            // Update the run group which has been toggled so that either all the runs are enabled or all of them are disabled (in which case it will not be shown)
            this.updateSelectedRunGroup(event);
          },
          _updateRunCheckboxesByGroup(group, isChecked){
            // Check all checkboxes whose name match the substring and regex
            const checkboxes = this.querySelectorAll('paper-checkbox');
            checkboxes.forEach(checkbox => {
              if(checkbox.name.includes(group) && checkbox.name in this.runSelectionState){
                this.runSelectionState[checkbox.name] = isChecked;
                checkbox.checked = isChecked;
              }
            });
          },
          updateSelectedRunGroup(event){
            const substring = event.target.name;
            const isChecked = event.target.checked;

            // Request for the set of runs to be either enabled or disabled
            if(isChecked){
              // Enable all the runs in the backend
              this._enableAllRunsMatchingRegexSubstring(substring).then(() => {
                this._updateRunCheckboxesByGroup(substring, isChecked);
              });
            }else{
              // Disable all the runs in the backend
              this._disableAllRunsMatchingRegexSubstring(substring).then(() => {
                this._updateRunCheckboxesByGroup(substring, isChecked);
              });
            }

            console.log(`group ${substring} set to ${isChecked}`);
          },
          updateRunGroups(){
            // Compute the run groups (without the filtering)
            const runGroups = this.computeRunGroups(this._runGroupKeys, this._displayedRunsRegex);
            // Compute the runs to disable
            const runsToDisable = [].concat.apply(runGroups.map(runGroup => runGroup.runs.map(run => run.run).filter(run => !this._displayedRunsRegex.test(run))))
            // Disable all the runs in the selection state
            runsToDisable.forEach(run => {
              this.runSelectionState[run] = false;
            });
            // Send request to backend to disable the displayed runs which do not match the regex (which will not be displayed anymore)
            if(runsToDisable && runsToDisable.length > 0){
              runGroups.forEach(runGroup => {
                const substring = runGroup.runKey;
                this._disableAllRunsNotMatchingRegexSubstring(substring);
              });
            }
            // Update the run groups
            this.set("_runGroups", runGroups.map(runGroup => ({groupKey: runGroup.runKey, runs: runGroup.runs.filter(run => this._displayedRunsRegex.test(run.run))})));
          },
          computeRunGroups(runGroupKeys, runRegex){
            const runGroupObject = this._runGroupObject;
            const runGroups = runGroupKeys.filter(runGroupKey => runGroupKey.checked).map(runGroupKey => ({groupKey: runGroupKey.runKey, runs: runGroupObject[runGroupKey.runKey].sort()}));
            console.log("printing the run groups");
            console.log(runGroups);
            return runGroups;
          },
          computeRunGroupKeys(runGroupObject){
            const runGroupKeys = Object.entries(runGroupObject).map((runGroup) => ({
              runKey: runGroup[0],
              checked: runGroup[1].some(run => run.checked)
            }));
            console.log("printing the run group keys");
            console.log(runGroupKeys);
            return runGroupKeys;
          },
          computeRunGroupObject(regex, runSelectionState){
            let runGroupObject = {}
            for(run in runSelectionState){
              const checked = runSelectionState[run];
              const key = run.match(regex);
              if(key != null){
                if(!(key in runGroupObject)){
                  runGroupObject[key] = [];
                }
                runGroupObject[key].push({run, checked});
              }
            }
            console.log("printing the run group object");
            console.log(runGroupObject)
            return runGroupObject;
          },
          disableRunsNotMatchingRegex(){
            const runsToDisable = this.runsNotMatchingRegex.filter(r => this.runSelectionState[r]);      
            // Send a request to the back end to update the run state to toggle all those runs which do not match the regex  
            this._disableRunsNotMatchingRegex().then(() => {
              runsToDisable.forEach(disableRun => {
                // We then have to disable the run if it was otherwise enabled
                this.runSelectionState[disableRun] = false;
              });
            });
          },
          _makeRegex(regexString) {
              try {
                  return new RegExp(regexString);
              } catch (e) {
                  return null;
              }
          },
          computeNamesNotMatchingRegex(runs, regex) {
            return regex ? runs.filter(run => !regex.test(run)) : [];
          },
          computeNamesMatchingRegex(runs, regex) {
              return regex ? runs.filter(run => regex.test(run)) : runs;
          },
          synchronizeColors(e) {
              const checkboxes = this.querySelectorAll('paper-checkbox');
              checkboxes.forEach(p => {
                  const color = this.coloring.getColor(p.name);
                  p.customStyle['--paper-checkbox-checked-color'] = color;
                  p.customStyle['--paper-checkbox-checked-ink-color'] = color;
                  p.customStyle['--paper-checkbox-unchecked-color'] = color;
                  p.customStyle['--paper-checkbox-unchecked-ink-color'] = color;
              });
              const buttons = this.querySelectorAll('.isolator');
              buttons.forEach(p => {
                  const color = this.coloring.getColor(p.name); // SARAH: might be worth investigating whether this line needs to be called on every iteration - will depend on what 'this' is in the forEach context
                  p.style['color'] = color;
              });
              // The updateStyles call fails silently if the browser doesn't have focus,
              // e.g. if TensorBoard was opened into a new tab that isn't visible.
              // So we wait for requestAnimationFrame.
              window.requestAnimationFrame(() => {
                  this.updateStyles();
              });
          },
          _checkboxChange(e) {
              var target = (Polymer.dom(e)).localTarget;
              const newSelectionState = _.clone(this.runSelectionState);
              const selectedRun = target.name;

              // Determine whether the checkbox was enabled or disabled
              const beforeState = newSelectionState[selectedRun];
              const afterState = target.checked;

              newSelectionState[selectedRun] = target.checked;
              // n.b. notifyPath won't work because names may have periods.
              this.runSelectionState = newSelectionState;

              // Send a request to enable / disable the run in the runsenabler backend
              if(beforeState && !afterState){
                  // Disabled
                  this._disableRun(selectedRun);
              }
              else if(!beforeState && afterState){
                  // Enabled
                  this._enableRun(selectedRun);
              }
          },
          _isChecked(run, outSelectedChange) { 
              return this.runSelectionState[run];
          },
          enableAll(){
            let allEnabledBefore = true;
            this.runsMatchingRegex.forEach((run) => {
              allEnabledBefore = allEnabledBefore && this.runSelectionState[run];
              this.runSelectionState[run] = true;
            });
            
            // Enable the run group structure
            this._runGroupKeys.forEach(runkey => {
              runkey.checked = true;
            });
            this.updateRunGroups();
            
            if(allEnabledBefore){
              this.enableAllCheckboxes();
            }else{
              this._enableAllRunsMatchingRegex().then(() => {
                this.enableAllCheckboxes();
              });
            }
          },
          disableAll(){
            let allDisabledBefore = true;
            this.runsMatchingRegex.forEach((run) => {
              allDisabledBefore = allDisabledBefore && !this.runSelectionState[run];
              this.runSelectionState[run] = false;
            });
            
            this._runGroupKeys.forEach(runkey => {
              runkey.checked = false;
            });
            this.updateRunGroups();
            
            if(allDisabledBefore){
              this.disableAllCheckboxes();
            }else{
              this._disableAllRunsMatchingRegex().then(() => {
                this.disableAllCheckboxes();
              });
            }
          },
          enableAllCheckboxes(){
            console.log("all runs which match the regex have their checkbox enabled");
            this.querySelectorAll('paper-checkbox').forEach(checkbox => {
              checkbox.checked = true; 
            });
          },
          disableAllCheckboxes(){
            console.log("all runs which match the regex have their checkbox disabled");
            this.querySelectorAll('paper-checkbox').forEach(checkbox => {
              checkbox.checked = false; 
            });
          },
          ready() {
              this.reload();
          },
          reload() {
              this._fetchRuns();
          },
          _fetchRuns(){
              const url = tf_backend.getRouter().pluginRoute('runsenabler', '/runs', new URLSearchParams({ enableNewRuns: this._enableNewRuns }));
              this.set('_isReloading', true);
              return this._requestManager.request(url).then(runState => {
                  this.set('_isReloading', false);
                  if (_.isEqual(runState, this.runSelectionState)) {
                      // No need to update anything if there are no changes.
                      return;
                  }
      
                  // Filter the selected runs to only be those contained in the new runState
                  const newRuns = Object.keys(runState);
      
                  this.set('runSelectionState', runState);
                  this.set('runs', newRuns.sort());
              });
          },
          _enableRun(run){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/enablerun', new URLSearchParams({
              run
            }));
            return this._requestManager.request(url);
          },
          _disableRun(run){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/disablerun', new URLSearchParams({
              run
            }));
            return this._requestManager.request(url);
          },
          _disableAllRunsMatchingRegex(){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/disableall', new URLSearchParams({regex: this._regex}));
            return this._requestManager.request(url);
          },
          _enableAllRunsMatchingRegex(){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/enableall', new URLSearchParams({regex: this._regex}));
            return this._requestManager.request(url);
          },
          _disableRunsNotMatchingRegex(){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/disablenonmatching', new URLSearchParams({regex: this._regex}));
            return this._requestManager.request(url);
          },
          _enableAllRunsMatchingRegexSubstring(substring){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/enableallsubstring', new URLSearchParams({regex: this._regex, substring, subregex: this._displayedRunsRegex}));
            return this._requestManager.request(url);
          },
          _disableAllRunsMatchingRegexSubstring(substring){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/disableallsubstring', new URLSearchParams({regex: this._regex, substring, subregex: this._displayedRunsRegex}));
            return this._requestManager.request(url);
          },
          _disableAllRunsNotMatchingRegexSubstring(substring){
            const url = tf_backend.getRouter().pluginRoute('runsenabler', '/disableallsubstringnonmatching', new URLSearchParams({regex: this._regex, substring, subregex: this._displayedRunsRegex}));
            return this._requestManager.request(url);
          },
        });
        tf_tensorboard.registerDashboard({
            plugin: 'runsenabler',
            elementName: 'runsenabler-dashboard'
        });
    </script>
</dom-module>