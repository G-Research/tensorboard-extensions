<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-menu/paper-menu.html">
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../tf-backend/tf-backend.html">
<link rel="import" href="../tf-categorization-utils/tf-categorization-utils.html">
<link rel="import" href="../tf-categorization-utils/tf-category-pane.html">
<link rel="import" href="../tf-categorization-utils/tf-tag-filterer.html">
<link rel="import" href="../tf-dashboard-common/array-update-helper.html">
<link rel="import" href="../tf-dashboard-common/dashboard-style.html">
<link rel="import" href="../tf-dashboard-common/tf-dashboard-layout.html">
<link rel="import" href="../tf-dashboard-common/tf-option-selector.html">
<link rel="import" href="../tf-imports/lodash.html">
<link rel="import" href="../tf-paginated-view/tf-paginated-view.html">
<link rel="import" href="../tf-runs-selector/tf-runs-selector.html">
<link rel="import" href="../tf-storage/tf-storage.html">
<link rel="import" href="../tf-tensorboard/registry.html">
<link rel="import" href="../tf-utils/tf-utils.html">
<link rel="import" href="paramplot-card.html">
<dom-module id="paramplot-dashboard">
  <template>
    <tf-dashboard-layout>
      <div class="sidebar">
        <div class="sidebar-section">
          <template is="dom-repeat" items="[[_tags]]" as="tag">
              <div id="tooltip-sorting">
                  <div>[[tag]]</div>
                    <paper-dropdown-menu no-label-float id="dropdown-[[tag]]">
                      <paper-menu class="dropdown-content" selected="0" slot="dropdown-content">
                        <paper-item>Most-Recent</paper-item>
                        <paper-item>Min</paper-item>
                        <paper-item>Max</paper-item>
                        <paper-item>Average</paper-item>
                      </paper-menu>
                    </paper-dropdown-menu>
                </div>
          </template>
        </div>
      </div>
      <div class="center">
        <template is="dom-if" if="[[_dataNotFound]]">
          <div class="no-data-warning">
            <h3>No scalar data was found.</h3>
            <p>Probable causes:</p>
            <ul>
              <li>You haven’t written any scalar data to your event files.
              <li>TensorBoard can’t find your event files.
              <li>I have introduced a bug somewhere....</li>
            </ul>
            <p>
              If you’re new to using TensorBoard, and want to find out how
              to add data and set up your event files, check out the
              <a href="https://github.com/tensorflow/tensorboard/blob/master/README.md">README</a>
              and perhaps the <a href="https://www.tensorflow.org/get_started/summaries_and_tensorboard">TensorBoard
                tutorial</a>.
              <p>
                If you think TensorBoard is configured properly, please see
                <a
                  href="https://github.com/tensorflow/tensorboard/blob/master/README.md#my-tensorboard-isnt-showing-any-data-whats-wrong">the
                  section of the README devoted to missing data problems</a>
                and consider filing an issue on GitHub.
          </div>
        </template>
        <template is="dom-if" if="[[!_dataNotFound]]">
          <template is="dom-repeat" items="[[_tagParameterFilters]]" as="filter">
            <paper-input
              id$="tag-regex-[[index]]"
              no-label-float
              label="Write a regex to filter tags (y axis values)"
              value="{{filter.tag}}"
              on-bind-value-changed="_debouncedTagRegexChange">
            </paper-input>
            <paper-input
              id$="parameter-regex-[[index]]"
              no-label-float
              label="Write a regex to filter parameters (x axis values)"
              value="{{filter.parameter}}"
              on-bind-value-changed="_debouncedParameterRegexChange">
            </paper-input>
            <tf-category-pane category="{{_categoryByIndex(index)}}" opened="{{_getPaneOpened(_categoryByIndex(index))}}" on-opened-changed="_onPaneOpenChanged">
              <tf-paginated-view items="{{_categoryByIndex(index).items}}" pages="{{_categoryByIndex(index)._pages}}">
                <template is="dom-repeat" items="{{_categoryByIndex(index)._pages}}" as="page">
                  <template is="dom-if" if="[[page.active]]">
                    <div class="layout horizontal wrap">
                      <template is="dom-repeat" items="[[page.items]]">
                          <paramplot-card active="[[page.active]]"
                            data-to-load="[[_getDataToLoadFromSeriesElement(item)]]"
                            request-manager="[[_requestManager]]" tag="[[item.tag]]"
                            parameter="[[item.parameter]]" x-type="[[_xType]]" aggregation-method="[[_tagAggregationMethod(item.tag)]]"></paramplot-card>
                        </template>
                    </div>
                  </template>
                </template>
              </tf-paginated-view>
            </tf-category-pane>
          </template>
        </template>
      </div>
    </tf-dashboard-layout>

    <style include="dashboard-style"></style>
    <style>
      .no-data-warning {
        max-width: 540px;
        margin: 80px auto 0 auto;
      }

      .center {
        overflow-x: hidden;
      }
    </style>
  </template>

  <script>
    Polymer({
      is: 'paramplot-dashboard',
      properties: {
        _paneOpened: {
          type: Object,
          value: () => ({}),
        },
        /** @type {vz_chart_helpers.XType} */
        _xType: {
          type: String,
          value: vz_chart_helpers.XType.STEP,
        },
        _runToTag: Object,
        _tags: Array,
        _parameters: Array,
        _dataNotFound: Boolean,
        _tagParameterFilters: {
          type: Array,
          value: () => [{tag: '', parameter: ''}]
        },
        // Categories must only be computed after _dataNotFound is found to be
        // true and then polymer DOM templating responds to that finding. We
        // thus use this property to guard when categories are computed.
        _categoriesDomReady: Boolean,
        _categories: {
          type: Array,
          value: () => [],
        },
        _categoryByIndex: {
          type: Function,
          value: function(){
            return index => this._categories[index] 
          }
        },
        _requestManager: {
          type: Object,
          value: () => new tf_backend.RequestManager(50),
        },
        _debouncedTagRegexChange: {
          type: Function,
          value: function(){
            return (event) => {
              const regexValue = event.detail.value;
              const id = event.target.dataHost.id;
              const index = parseInt(id.split('-')[2]);
              return this._debouncedRegexChangeByType('tag', index, regexValue);
            } 
          }
        },
        _debouncedParameterRegexChange: {
          type: Function,
          value: function(){
            return (event) => {
              const regexValue = event.detail.value;
              const id = event.target.dataHost.id;
              const index = parseInt(id.split('-')[2]);
              return this._debouncedRegexChangeByType('parameter', index, regexValue);
            } 
          }
        },
        _debouncedRegexChangeByType: {
          type: Function,
          value: function(){
            return (type, index, value) => {
              const regexUpdate = (type == 'tag') ? ((val) => this._tagParameterFilters[index].tag = val) : ((val) => this._tagParameterFilters[index].parameter = val)  
              const debounced = _.debounce(r => {
                      regexUpdate(r);
                      console.log(r);
                  }, 150, {leading: false});
              return function() {
                console.log(value);
                console.log(type);
                if (value == '') {
                    // If the user cleared the field, they may be done typing, so
                    // update more quickly.
                    this.async(() => {
                        regexUpdate(value);
                        console.log(value);
                    }, 30);
                } else {
                    debounced(value);
                };
              };
            }
          } 
        }
      },
      behaviors: [
        tf_dashboard_common.ArrayUpdateHelper,
      ],
      // observers: [
      //   '_updateCategories(_runToTag, _categoriesDomReady)',
      // ],
      _getDataToLoadFromSeriesElement(seriesElement) {
        return [seriesElement];
      },
      _getCategoryKey(category) {
        return category.name
      },
      _getPaneOpened(category) {
        return this._paneOpened[this._getCategoryKey(category)];
      },
      _onPaneOpenChanged(event) {
        // The event can be triggered without the pane being mounted.
        if (!this.isAttached || !event.target.isAttached) return;
        const name = this._getCategoryKey(event.target.category);
        this._paneOpened[name] = event.detail.value;
      },
      ready() {
        this.reload();
      },
      reload() {
        this._fetchParameters()
          .then(() => this._fetchTags()
            .then(() => {
              this._updateCategories();
              this._reloadCharts();
            }));
        console.log(this._tagParameterFilters);
      },
      _fetchTags() {
        const url = tf_backend.getRouter().pluginRoute('paramplot', '/tags');
        return this._requestManager.request(url).then(runToTag => {
          if (_.isEqual(runToTag, this._runToTag)) {
            // No need to update anything if there are no changes.
            return;
          }
          const tags = tf_backend.getTags(runToTag);
          this.set('_dataNotFound', tags.length === 0);
          this.set('_tags', tags);
          this.set('_runToTag', runToTag);
          this.async(() => {
            // See the comment above `_categoriesDomReady`.
            this.set('_categoriesDomReady', true);
          });
        });
      },
      _fetchParameters() {
        const url = tf_backend.getRouter().pluginRoute('paramplot', '/parameters');
        return this._requestManager.request(url).then(parameterData => {
          if (_.isEqual(parameterData.payload, this._parameters)) {
            // No need to update anything if there are no changes.
            return;
          }
          this.set('_parameters', parameterData.payload);
        });
      },
      _reloadCharts() {
        this.querySelectorAll('paramplot-card').forEach(chart => {
          chart.reload();
        });
      },
      _updateCategories() {
        if(!this._parameters || !this._tags){
          return;
        }      

        console.log('both parameters and tags have been loaded, now create the categories')

        this._createAndUpdateCategories();
      },
      _createAndUpdateCategories(){
        console.log('Now rendering the categories');

        // There should be an identical number of tagFilters and parameterFilters
        categories = this._tagParameterFilters.map((tagFilter, index, arr) => {
          // Obtain filtered categories for both kinds of filters
          let categoryByTag = tf_categorization_utils.categorizeBySearchQuery(this._tags, tagFilter.tag);
          let categoryByParameter = tf_categorization_utils.categorizeBySearchQuery(this._parameters, tagFilter.parameter);
          
          let categoryItems = categoryByTag.items.map(tag => categoryByParameter.items.map(parameter => ({tag, parameter})));
          categoryItems = categoryItems.reduce((a,b) => a.concat(b), [])

          // Merge the two categories into a single category
          return {
            name: `${categoryByTag.name} ${categoryByParameter.name}`,
            metadata: {
              type: categoryByTag.metadata.type,
              validRegex: categoryByTag.metadata.validRegex && categoryByParameter.metadata.validRegex,
              universalRegex: categoryByTag.metadata.universalRegex || categoryByParameter.metadata.universalRegex
            },
            items: categoryItems
          }
        });
        console.log('_createAndUpdateCategories');
        console.log(categories);

        this.updateArrayProp('_categories', categories, this._getCategoryKey);
      },
      _tagAggregationMethod(tag){
        var selector = document.getElementById(`dropdown-${tag}`);
        return () => {
          return selector.selectedItemLabel;
        };
      }
    });
    tf_tensorboard.registerDashboard({
      plugin: 'paramplot',
      elementName: 'paramplot-dashboard'
    });
  </script>
</dom-module>